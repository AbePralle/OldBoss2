module Boss
  uses ParseKit<<Boss>>

#==============================================================================
# BossVM
#==============================================================================
class BossVM
  PROPERTIES
    stack = Int64[]

    is_prepared : Logical

    modules     = LookupList<<BossModule>>()
    module_list = BossModule[]

    module_boss : BossModule

    internal_t  = Token( TokenType.EOI, "[BossVM]", 0, 0 )

    type_Int32  : BossType

  METHODS
    method init
      type_Int32 = define_type( "Int32", BossType.IS_PRIMITIVE )

    method create_module( name:String, filepath:String )->BossModule
      is_prepared = false
      local m = BossModule( this, name, filepath )
      module_list.add( m )
      return m

    method define_type( name:String, attributes=0:Int32, slot_count=1:Int32 )->BossType
      attributes |= BossType.IS_DEFINED
      if (not module_boss)
        module_boss = create_module( "boss", "[BossVM]" )
        modules//boss = module_boss
      endIf
      local type = module_boss.get_type( internal_t, name, BossType.IS_DEFINED )
      type.slot_count = slot_count
      return type

    method execute( command:String )
      local scope = BossScope( module_boss )

      local statements = CmdStatements()
      BossParser().[ set_source("[Native Code]",command) ].parse_multi_line_statements( statements )

      prepare
      statements.resolve( scope )
      statements.execute( this )

    method evaluate( command:String, required_type:BossType )
      # Result is left on stack
      local scope = BossScope( module_boss )

      local statements = CmdStatements()
      BossParser().[ set_source("[Native Code]",command) ].parse_multi_line_statements( statements )

      if (statements.is_empty)
        local t = Token( TokenType.EOI, "[Native Code]", 0, 0 )
        throw t.error( "Expression does not evaluate to required type $." (required_type) )
      elseIf (statements.count > 1)
        local t = Token( TokenType.EOI, "[Native Code]", 0, 0 )
        throw t.error( "Cannot evaluate() multiple commands." )
      endIf

      local expression = statements.remove_last

      expression.require_type( scope, required_type )
      prepare
      expression = expression.resolved( scope )
      expression.execute( this )

    method evaluate_int32( command:String )->Int32
      evaluate( command, type_Int32 )
      return pop_int32

    method load( filepath:String )->BossModule
      return load( internal_t, filepath )

    method load( t:Token, filepath:String )->BossModule
      local module_name = filepath
      local m = modules[ module_name ]
      if (m) return m

      if (module_name.ends_with(".boss",&ignore_case))
        module_name = module_name.before_suffix( ".boss", &ignore_case )
      else
        filepath = filepath + ".boss"
      endIf

      if (not File.exists(filepath)) throw t.error( "No such file: " + filepath )

      local abs_filepath = File.absolute_filepath( filepath )
      m = modules[ abs_filepath ]
      if (m) return m

      m = create_module( module_name, abs_filepath )
      modules[ module_name ] = m
      modules[ filepath ] = m
      modules[ abs_filepath ] = m

      parse( m, File.load_as_string(abs_filepath) )

      return m


    method parse( filename:String, source:String )->BossModule
      local m = create_module( filename.before_suffix(".boss",&ignore_case), filename )
      parse( m, source )
      return m

    method parse( m:BossModule, source:String )
      BossParser().parse( m, source )

    method parse_expression( filename:String, source:String )->Cmd
      return BossParser().[ set_source(filename,source) ].parse_expression()

    method push( value:Int32 ) [macro]
      this.stack.add( value )

      #{
    method push( value:BossValue )
      stack.add( value )
      }#

    method pop_and_add( slot_count:Int32, list:Int64[] )
      if (slot_count == 1)
        list.add( stack.remove_last )
      else
        local i1 = stack.count - slot_count
        forEach (delta in 0..<slot_count) list.add( stack[i1+delta] )
      endIf

    method pop_int32->Int32 [macro]
      return this.stack.remove_last->Int32

    method prepare
      if (is_prepared) return

      is_prepared = true
      (forEach in module_list).prepare
endClass

