module Boss
  uses ParseKit<<Boss>>

#==============================================================================
# BossVM
#==============================================================================
class BossVM
  #{
  ENUMERATE
    STATUS_NORMAL    = 0
    STATUS_RETURNING
    }#

  PROPERTIES
    module_list     = BossModule[]
    module_lookup   = StringTable<<BossModule>>()
    is_resolved     : Logical

    default_module     : BossModule
    default_type_Value : BossType

    #{
    stack = BossValue[]
    fp    : Int32

    id_table     = LookupList<<Int32>>()
    global_vars  = LookupList<<BossValue>>()
    }#

    parser       = BossParser()

    #{
    last_error   : BossError

    is_resolved  : Logical
    }#

    #types        = LookupList<<BossType>>()
    #methods      = LookupList<<BossMethod>>()

    #{
    type_Object  : BossType
    type_Global  : BossType

    global_statements = CmdStatements()
    m_on_launch      : BossMethod

    locals      = BossLocal[]

    this_type   : BossType
    this_method : BossMethod

    status = STATUS_NORMAL : Int32
    }#

  METHODS
    method init
      default_module = add_module( "Default" )
      default_type_Value = default_module.define_type( "Value" )

    #{
    method init
      internal_t   = Token( TokenType.EOI, "[BossVM]", 0, 0 )

      type_Object  = get_type( "Object" )
      type_Global  = get_type( "Global" )

      global_vars//Global = BossValue( BossObject(type_Global) )
      clear_global_statements

      id_init = id( "init" )
      }#

    method add_module( filepath:String )->BossModule
      is_resolved = false
      local m = BossModule( this, filepath )
      module_list.add( m )
      return m

      #{
    method call( m_id:Int32, argc:Int32 )->BossValue
      local new_fp = stack.count - (argc+1)
      local context = stack[ new_fp ]
      local context_type : BossType
      if (context.type == BossValue.TYPE_OBJECT)
        local obj = context.object as BossObject
        if (not obj) return UndefinedBossValue
        context_type = obj.type
        return UndefinedBossValue
      else
        return UndefinedBossValue
      endIf

    method clear_global_statements
      m_on_launch = type_Global.get_method( "on_execute" )
      m_on_launch.statements.clear
      }#

    method execute( filename:String, source:String )->BossValue
      try
        local m = add_module( filename )
        if (parse(m,source))
          resolve
          return m.execute
        endIf
      catch (err:BossError)
        err.print
      endTry
      return UndefinedBossValue

      #{
    method execute->BossValue
      try
        if (not is_resolved)
          m_on_launch.statements.add( global_statements )
          global_statements.clear
          (forEach in types).resolve
        endIf

        stack.clear
        push( BossValue(type_Global.get_singleton) )
        m_on_launch.call( 0 )
        clear_global_statements
        return pop

      catch ( err:BossError )
        clear_global_statements
        throw err

      endTry

    method find_local( name:String )->BossLocal?
      forEach (v in locals)
        if (v.name == name) return v
      endForEach
      return null

    method get( name:String )->BossValue [macro]
      return this.global_vars[ name ]
      }#

    method get_module( filepath:String )->BossModule
      local m = module_lookup[ filepath ]
      if (m) return m
      m = add_module( filepath )
      module_lookup[ filepath ] = m
      return m

      #{
    method get_type( t:Token, name:String, attributes=0:Int32 )->BossType
      local result = types[ name ]
      if (result)
        if (result.t is internal_t)
          result.t = t
          result.attributes = attributes
        endIf
      else
        result = BossType( this, t, name, types.count, attributes )
        types[ name ] = result
      endIf
      return result

    method get_type( name:String, attributes=0:Int32 )->BossType
      return get_type( internal_t, name, attributes )

    method id( st:String )->Int32
      local index = id_table.locate( st )
      if (index.exists) return index.value

      local result = id_table.count
      id_table[ st ] = result
      return result
      }#

    method parse( m:BossModule, source:String )->Logical
      try
        local scope = BossScope( m )
        parser.scope = scope
        parser.set_source( m.filepath, source )
        loop
          if (parser.parse_component) nextIteration

          scope.this_type   = scope.this_module.type_Global
          scope.this_method = scope.this_module.m_on_launch
          if (parser.parse_multi_line_statements(scope.this_method.statements)) nextIteration

          escapeLoop
        endLoop
        return true
      catch (err:BossError)
        err.print
        return false
      endTry

      #{
    method parse( filepath:String )->Logical
      return parse( filepath, File.load_as_string(filepath) )

    method parse( filepath:String, source:String )->Logical
      is_resolved = false
      type_Global.is_resolved = false

      try
        parser.set_source( filepath, source )
        loop
          if (parser.parse_component) nextIteration

          this_method = m_on_launch
          this_type = this_method.type_context
          if (parser.parse_multi_line_statements(global_statements)) nextIteration

          escapeLoop
        endLoop
        return true
      catch (err:BossError)
        err.print
        return false
      endTry

    method peek->BossValue
      if (not stack.count) throw BossError( "BossVM.peek() on empty stack." )
      return stack.last

    method push( value:BossValue ) [macro]
      this.stack.add( value )

    method pop->BossValue
      if (not stack.count) throw BossError( "BossVM.pop() on empty stack." )
      return stack.remove_last
      }#

    method resolve
      if (is_resolved) return
      is_resolved = true
      (forEach in module_list).resolve

      #{
    method set( name:String, new_value:BossValue ) [macro]
      this.global_vars[ name ] = new_value

    method type_of( value:BossValue )->BossType
      local obj = value.object as BossObject
      if (obj) return obj.type
      return null
      }#
endClass

