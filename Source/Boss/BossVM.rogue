module Boss
  uses ParseKit<<Boss>>

#==============================================================================
# BossVM
#==============================================================================
class BossVM
  PROPERTIES
    stack = Real64[]

    is_prepared : Logical

    modules     = LookupList<<BossModule>>()
    module_list = BossModule[]

    module_boss : BossModule

    internal_t  = Token( TokenType.EOI, "[BossVM]", 0, 0 )

    type_Int32  : BossType

  METHODS
    method init
      type_Int32 = define_type( "Int32", BossType.IS_PRIMITIVE )

    method create_module( filepath:String, name:String )->BossModule
      is_prepared = false
      local m = BossModule( this, filepath, name )
      module_list.add( m )
      return m

    method define_type( name:String, attributes=0:Int32, data_count=1:Int32 )->BossType
      attributes |= BossType.IS_DEFINED
      if (not module_boss)
        module_boss = create_module( "[BossVM]", "boss" )
        modules//boss = module_boss
      endIf
      local type = module_boss.get_type( internal_t, name, BossType.IS_DEFINED )
      type.data_count = data_count
      return type

    method execute( command:String )
      local scope = BossScope( module_boss )

      local statements = CmdStatements()
      BossParser().[ set_source("[Native Code]",command) ].parse_multi_line_statements( statements )

      prepare
      statements.resolve( scope )
      statements.execute( this )

    method evaluate( command:String, required_type:BossType )
      # Result is left on stack
      local scope = BossScope( module_boss )

      local statements = CmdStatements()
      BossParser().[ set_source("[Native Code]",command) ].parse_multi_line_statements( statements )

      if (statements.is_empty)
        local t = Token( TokenType.EOI, "[Native Code]", 0, 0 )
        throw t.error( "Expression does not evaluate to required type $." (required_type) )
      elseIf (statements.count > 1)
        local t = Token( TokenType.EOI, "[Native Code]", 0, 0 )
        throw t.error( "Cannot evaluate() multiple commands." )
      endIf

      local expression = statements.remove_last

      expression.require_type( scope, required_type )
      prepare
      expression = expression.resolved( scope )
      expression.execute( this )

    method evaluate_int32( command:String )->Int32
      evaluate( command, type_Int32 )
      return pop_int32

      #{
    method import( t:Token, filepath:String )->BossModule
      local m = modules[ filepath ]
      if (m) return m

      local original_filepath = filepath

      if (File.is_folder(filepath)) throw t.error( "Importing a folder is not yet supported." )

      if (not filepath.ends_with(".boss",&ignore_case)) filepath += ".boss"
      if (File.exists(filepath))
        filepath = File.absolute_filepath( filepath )
      else
        throw t.error( "Can't find import: " + filepath )
      endIf

      m = create_module( filepath, File.filename(filepath).before_suffix(".boss",&ignore_case) )
      modules[ original_filepath ] = m
      modules[ filepath ] = m

      local source = File.load_as_string( filepath )
      if (parse(m,source))
        m.resolve
        m.launch
      endIf

      return m
      }#

    method parse( filename:String, source:String )->BossModule
      local m = create_module( filename, filename.before_suffix(".boss",&ignore_case) )
      parse( m, source )
      return m

    method parse( m:BossModule, source:String )
      BossParser().parse( m, source )

    method parse_expression( filename:String, source:String )->Cmd
      return BossParser().[ set_source(filename,source) ].parse_expression()

    method push( value:Int32 ) [macro]
      this.stack.add( value )

      #{
    method push( value:BossValue )
      stack.add( value )
      }#

    method pop_int32->Int32 [macro]
      return this.stack.remove_last->Int32

    method prepare
      if (is_prepared) return

      is_prepared = true
      (forEach in module_list).prepare
endClass

